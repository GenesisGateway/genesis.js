// Generated by CoffeeScript 2.5.1
(function() {
  var Base, Currency, Promise, Request, Validator, _;

  Request = require('../request');

  Currency = require('../helpers/currency');

  _ = require('underscore');

  Validator = require('../helpers/validators/validator');

  Promise = require('bluebird');

  Base = class Base {
    constructor(params) {
      this.params = params;
      this.request = new Request();
      this.currency = new Currency();
      /*
      Define transaction required fields
      E.g. ['amount', 'country']
      */
      this.requiredFields = [];
      /*
      Define transaction required fields OR. At least one of listed fields should be filled
      E.g. ['amount', 'country']
      */
      this.requiredFieldsOr = [];
      /*
      Define transaction conditionally required fields
      E.g. 'currency':
              'USD': [
                'bank_account'
              ]
      E.g. 'notification_url': ['return_success_url', 'return_failure_url']
      */
      this.requiredFieldsConditional = {};
      /*
      Define transaction fields allowed values
      E.g. 'currency': ['EUR', 'USD']
      */
      this.fieldsValues = {};
      /*
      Define transaction fields conditionally allowed values
      E.g. 'currency':
              'USD': {
                'card_number': new RegExp '^[0-9]{20}$'
              }
      E.g. 'state':
              'country': ['US', 'CA']
      */
      this.fieldsValuesConditional = {};
      /*
      Define transaction groups of required fields. At least one group should be filled
      E.g. 'asynchronous':
             ['notification_url', 'return_success_url', 'return_failure_url']
           'synchronous':
             ['mpi_eci']
      */
      this.requiredFieldsGroups = {};
    }

    setData(params) {
      this.params = params;
      return this;
    }

    /*
      Get field value using dot notation
    */
    getValue(field) {
      return field.split('.').reduce(function(a, b) {
        if (!_.isUndefined(a)) {
          return a[b];
        } else {
          return void 0;
        }
      }, this.params);
    }

    validateRequiredFields(fields = this.requiredFields, message_suffix = "") {
      var field, fieldValue, i, len, results;
      results = [];
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        fieldValue = this.getValue(field);
        if (!fieldValue || (_.isObject(fieldValue) && _.isEmpty(fieldValue))) {
          results.push(this.validationErrors.push(`Field ${field} is required` + message_suffix));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    validateRequiredFieldsOr(fields = this.requiredFieldsOr) {
      var field, i, len, show_error;
      if (fields.length) {
        show_error = true;
        for (i = 0, len = fields.length; i < len; i++) {
          field = fields[i];
          if (this.getValue(field)) {
            show_error = false;
            break;
          }
        }
        if (show_error) {
          return this.validationErrors.push(`At least one of ${fields.join(', ')} fields has to be filled`);
        }
      }
    }

    validateRequiredFieldsConditional() {
      var conditions, field, fieldValue, ref, results;
      ref = this.requiredFieldsConditional;
      results = [];
      for (field in ref) {
        conditions = ref[field];
        fieldValue = this.getValue(field);
        if (!_.isUndefined(fieldValue) && !_.isEmpty(fieldValue)) {
          // if fields are required when given field exists
          if (_.isArray(conditions)) {
            results.push(this.validateRequiredFields(conditions, ` when ${field} is not empty`));
          // if fields are required when given field has exact value
          } else if (_.isObject(conditions) && !_.isUndefined(conditions[fieldValue])) {
            results.push(this.validateRequiredFields(conditions[fieldValue], ` when ${field} is ${fieldValue}`));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    validateFieldsValues(fields = this.fieldsValues, message_suffix = "") {
      var field, fieldValue, results, value;
      results = [];
      for (field in fields) {
        value = fields[field];
        fieldValue = this.getValue(field);
        if (!_.isUndefined(fieldValue)) {
          // check if field value exists in the given array
          if (_.isArray(value)) {
            if (_.indexOf(value, fieldValue) === -1) {
              results.push(this.validationErrors.push(`Field ${field} has invalid value. ` + `Allowed values are: ${value.join(', ')}` + message_suffix));
            } else {
              results.push(void 0);
            }
          // check if field value match the given regular expression
          } else if (_.isRegExp(value)) {
            if (!value.test(fieldValue)) {
              results.push(this.validationErrors.push(`Field ${field} has invalid value. Allowed format is ${value}` + message_suffix));
            } else {
              results.push(void 0);
            }
          // check if field value pass given validator
          } else if (value instanceof Validator) {
            if (!value.isValid(fieldValue)) {
              results.push(this.validationErrors.push(value.getMessage(field) + message_suffix));
            } else {
              results.push(void 0);
            }
          // check if field value match exact given value
          } else if (typeof value === 'string' || _.isNumber(value)) {
            if (fieldValue !== value) {
              results.push(this.validationErrors.push(`Field ${field} has invalid value. Allowed value is ${value}` + message_suffix));
            } else {
              results.push(void 0);
            }
          // if value is object check conditional values
          } else if (_.isObject(value)) {
            results.push(this.validateFieldsValuesConditional(_.pick(fields, field), message_suffix));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    validateFieldsValuesConditional(fields = this.fieldsValuesConditional, message = "") {
      var conditions, field, fieldValue, results;
      results = [];
      for (field in fields) {
        conditions = fields[field];
        fieldValue = this.getValue(field);
        if (!_.isUndefined(fieldValue) && !_.isEmpty(fieldValue)) {
          // check fields values if given field exists
          if (_.isUndefined(conditions[fieldValue])) {
            results.push(this.validateFieldsValues(conditions, ` when ${field} is not empty`));
          } else {
            // check fields values if given field has exact value
            results.push(this.validateFieldsValues(conditions[fieldValue], message + ` ${message ? "and" : "when"} ${field} is ${fieldValue}`));
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    validateRequiredFieldsGroups() {
      var emptyFieldInGroup, field, fieldValue, fields, group, groupsFormatted, hasOneFilledGroup, i, len, ref;
      if (!_.isEmpty(this.requiredFieldsGroups)) {
        groupsFormatted = [];
        hasOneFilledGroup = false;
        ref = this.requiredFieldsGroups;
        for (group in ref) {
          fields = ref[group];
          groupsFormatted.push(`${group}(${fields.join(', ')})`);
          emptyFieldInGroup = false;
          for (i = 0, len = fields.length; i < len; i++) {
            field = fields[i];
            fieldValue = this.getValue(field);
            if (!fieldValue || (_.isObject(fieldValue) && _.isEmpty(fieldValue))) {
              emptyFieldInGroup = true;
            }
          }
          if (!emptyFieldInGroup) {
            hasOneFilledGroup = true;
          }
        }
        if (!hasOneFilledGroup) {
          return this.validationErrors.push(`One of the following group/s of field/s must be filled in: ${groupsFormatted.join('; ')}`);
        }
      }
    }

    isValid() {
      this.validationErrors = [];
      this.validateRequiredFields();
      this.validateRequiredFieldsOr();
      this.validateRequiredFieldsConditional();
      this.validateFieldsValues();
      this.validateFieldsValuesConditional();
      this.validateRequiredFieldsGroups();
      return this.validationErrors.length === 0;
    }

    send() {
      var args;
      if (!this.isValid()) {
        return Promise.reject(this.validationErrors);
      }
      args = {
        trx: this.getTrxData(),
        url: this.getUrl()
      };
      return this.request.send(args);
    }

  };

  module.exports = Base;

}).call(this);
