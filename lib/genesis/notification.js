// Generated by CoffeeScript 2.7.0
(function() {
  var Config, Notification, Promise, Transaction, bodyParser, connect, crypto, http, util, xmlObj;

  crypto = require('crypto');

  http = require('http');

  util = require('util');

  connect = require('connect');

  xmlObj = require('xml-object');

  bodyParser = require('body-parser');

  Promise = require('bluebird');

  Transaction = require('./transaction');

  Config = require('./utils/configuration/config');

  Notification = class Notification {
    constructor(configuration = null) {
      this.getUrl = this.getUrl.bind(this);
      this.callbacks = {};
      this.conf = configuration;
      this.configuration = new Config(this.conf);
      this.listener = this.configuration.getNotifications();
    }

    /*
      Setup a listener for incoming notification requests
    */
    listen(onSuccess, onFailure) {
      var listener, server;
      listener = connect();
      listener.use(bodyParser.urlencoded({
        extended: true
      }));
      listener.use(this.listener.path, (request, response) => {
        return this.handle(request, response).then(onSuccess).catch(onFailure);
      });
      server = http.createServer(listener);
      server.listen(this.listener.port, this.listener.host);
      return console.log(util.format('[notifier] listen on: %s:%s%s', this.listener.host, this.listener.port, this.listener.path));
    }

    /*
      Verify request and send reconcile
      @return Promise
    */
    handle(request, response) {
      var params, valid_request;
      params = request.body;
      valid_request = this.verifySignature(params);
      this.output(params, response, valid_request);
      if (valid_request) {
        return this.reconcile(params);
      } else {
        return Promise.reject('Invalid Signature');
      }
    }

    output(params, response, valid_request = true) {
      response.setHeader('Content-Type', 'text/xml');
      if (valid_request === false) {
        response.writeHead(400);
      }
      response.write(this.echoConfirmation(params));
      return response.end('');
    }

    /*
      Initiate a reconcile with Genesis Gateway
      @return Promise Returns transaction request promise
    */
    reconcile(params) {
      var reconcileParams, transaction;
      transaction = new Transaction(this.conf);
      reconcileParams = {
        unique_id: params.wpf_unique_id || params.unique_id
      };
      if (this.isWpfNotification(params)) {
        return transaction.wpf_reconcile(reconcileParams).send();
      } else {
        return transaction.reconcile(reconcileParams).send();
      }
    }

    /*
      Respond to Genesis as expected
      @return string Returns XML format expected from gateway
    */
    echoConfirmation(params) {
      var response_body;
      if (this.isWpfNotification(params)) {
        response_body = {
          notification_echo: {
            'wpf_unique_id': params.wpf_unique_id
          }
        };
      } else {
        response_body = {
          notification_echo: {
            'unique_id': params.unique_id
          }
        };
      }
      return xmlObj(response_body, {
        declaration: true
      });
    }

    /*
      Verify an incoming request's signature
      @return boolean
    */
    verifySignature(params) {
      var hash, unique_id;
      if (!params.signature) {
        return false;
      }
      if (this.isWpfNotification(params)) {
        unique_id = params.wpf_unique_id;
      } else {
        unique_id = params.unique_id;
      }
      switch (params.signature.length) {
        case 40:
          hash = crypto.createHash('sha1').update(unique_id + this.configuration.getCustomerPassword()).digest('hex');
          break;
        case 64:
          hash = crypto.createHash('sha256').update(unique_id + this.configuration.getCustomerPassword()).digest('hex');
          break;
        case 128:
          hash = crypto.createHash('sha512').update(unique_id + this.configuration.getCustomerPassword()).digest('hex');
          break;
        default:
          hash = new String();
      }
      if (hash.toString() !== params.signature.toString()) {
        return false;
      }
      return true;
    }

    /*
      Check if request is WPF or Processing
    */
    isWpfNotification(params) {
      if (params.wpf_unique_id) {
        return true;
      }
      return false;
    }

    getUrl() {
      return util.format('http://%s:%s%s', this.listener.host, this.listener.port, this.listener.path);
    }

  };

  module.exports = Notification;

}).call(this);
